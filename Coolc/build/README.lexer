Make file targets

lexer: builds the lexer which pronts its tokens on the console
dotest: Tests the lexer

Lexer.java:
    The Main class for the lexer. Reads a cool source file and outputs tokens
    on the console.

AbstractSymbol.java
StringSymbol.java
IntSymbol.java
IdSymbol.java
AbstractTable.java
StringTable.java
IntTable.java
IdTable.java
    The same strings constants, integer constants and identifiers(type and
    object identifiers) occur multiple times in a program. There is a need to store and manage them efficiently which is done by lookup tables, 
    
README file for Programming Assignment 2 (Java edition)
=======================================================

	TokenConstants.java contains constant definitions that are used by
	almost all parts of the compiler. DO NOT MODIFY.


	Utilities.java contains various support functions used by the
	main lexer driver (Lexer.java).  DO NOT MODIFY.

	Lexer.java contains the main method which will call your lexer
	and print out the tokens that it returns.  DO NOT MODIFY.

        CoolLexer.java is the scanner generated by jlex from cool.lex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run jlex.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.
