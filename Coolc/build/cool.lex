/*
 *  The scanner definition for COOL. This scanner is generated by my specification file
 */


/*
 * User Code
 * Stuff here is copied verbatim into the lexer source file that Jlex outputs.
 */
package cool.lexer;
import java_cup.runtime.Symbol;
import cool.common.AbstractSymbol;
import cool.common.AbstractTable;
import cool.common.EscapedNullInCoolStringException;
import cool.common.NullInCoolStringException;
import cool.parser.TokenConstants;

%%

%{

/*  Stuff enclosed in %{ %} is copied verbatim to the lexer class
 *  definition. All the extra variables/functions used in the
 *  lexer actions goes here.  
 */

    // Max size of cool string constants
    static int MAX_STR_CONST = 1024;

    // For assembling string constants
    CoolStringBuilder coolStr = new CoolStringBuilder();

    // Helps identify the line number of the tokens
    private int curr_lineno = 1;

    // Used to print the lexer output by Utilities.dumptoken()
    public int curr_lineno() { return curr_lineno; }

    private AbstractSymbol filename;
    public void set_filename(String fname) {
	filename = AbstractTable.stringtable.addString(fname);
    }

    public AbstractSymbol curr_filename() {
	return filename;
    }

    // used to track the nesting level of comments
    private int nested = 0;
%}

%init{

/*  Stuff enclosed in %init{ %init} is copied verbatim to the lexer
 *  class constructor.
 */

%init}

%eofval{

/*  Stuff enclosed in %eofval{ %eofval} specifies java code that is
 *  executed when end-of-file is reached.
 *  Ultimately, an EOF symbol is returned by the scanner to indicate that the
 *  file has been scanned
 */

    switch(yy_lexical_state) {
    case STRING:
        yybegin(YYINITIAL);
        if (!coolStr.inError())
            return new Symbol(TokenConstants.ERROR, 
                "EOF in string constant");
    case COMMENT:        
        yybegin(YYINITIAL);
            return new Symbol(TokenConstants.ERROR,
                "EOF in comment");
    }
    return new Symbol(TokenConstants.EOF);
%eofval}

%class CoolTokenLexer 
%cup
%public

DARROW    =      =>
ASSIGN    =      <-
LE        =      <=
a         =      [aA]
b         =     [bB]
c         =     [cC]
d         =     [Dd]
e         =     [Ee]
f         =     [Ff]
g         =     [Gg]
h         =     [Hh]
i         =     [Ii]
j         =     [Jj]
k         =     [Kk]
l         =     [Ll]
m         =     [Mm]
n         =     [Nn]
o         =     [Oo]
p         =     [Pp]
q         =     [Qq]
r         =     [Rr]
s         =     [Ss]
t         =     [Tt]
u         =     [Uu]
v         =     [Vv]
w         =     [Ww]
x         =     [Xx]
y         =     [Yy]
z         =     [Zz]

QUOTE     =     \"
NEWLINE   =     \n
SLASH     =     \\
ESC_SEQ   =     {SLASH}.|{SLASH}{NEWLINE}

%state COMMENT
%state STRING

%%
<YYINITIAL>\(\*       { yybegin(COMMENT);  }
<COMMENT>[^*(\n]+     {/* Ignore anything that is not '*' or '(' or '\n' */}
<COMMENT>\*[^)]       {/* Ignore a '*' not followed by a ')'*/}
<COMMENT>\([^*]       {/* Ignore a '(' not followed by a '*' */}
<COMMENT>\n           { ++curr_lineno; }
<COMMENT>\(\*         { nested++; }
<COMMENT>[*]+\)       {
                      if (nested == 0) 
                          yybegin(YYINITIAL);
                      else
                          nested--; 
                      }
<YYINITIAL>\*\)       { return new Symbol(TokenConstants.ERROR, "Unmatched *)");}
<YYINITIAL>"--"[^\n]* {/* Single line comment*/;}


<YYINITIAL>{DARROW} { return new Symbol(TokenConstants.DARROW); }
<YYINITIAL>{ASSIGN} { return new Symbol(TokenConstants.ASSIGN); }
<YYINITIAL>{LE}     { return new Symbol(TokenConstants.LE); }


<YYINITIAL>~    { return new Symbol(TokenConstants.NEG); }
<YYINITIAL>\+   { return new Symbol(TokenConstants.PLUS); }
<YYINITIAL>\-   { return new Symbol(TokenConstants.MINUS); }
<YYINITIAL>\*   { return new Symbol(TokenConstants.MULT); }
<YYINITIAL>\/   { return new Symbol(TokenConstants.DIV); }
<YYINITIAL>\<   { return new Symbol(TokenConstants.LT); }
<YYINITIAL>\{   { return new Symbol(TokenConstants.LBRACE); }
<YYINITIAL>\}   { return new Symbol(TokenConstants.RBRACE); }
<YYINITIAL>\(   { return new Symbol(TokenConstants.LPAREN); }
<YYINITIAL>\)   { return new Symbol(TokenConstants.RPAREN); }
<YYINITIAL>:    { return new Symbol(TokenConstants.COLON); }
<YYINITIAL>;    { return new Symbol(TokenConstants.SEMI); }
<YYINITIAL>,    { return new Symbol(TokenConstants.COMMA); }
<YYINITIAL>=    { return new Symbol(TokenConstants.EQ); }
<YYINITIAL>\.   { return new Symbol(TokenConstants.DOT); }
<YYINITIAL>@    { return new Symbol(TokenConstants.AT); }


<YYINITIAL>{c}{l}{a}{s}{s}     { return new Symbol(TokenConstants.CLASS); }
<YYINITIAL>{e}{l}{s}{e}        { return new Symbol(TokenConstants.ELSE); }
<YYINITIAL>{f}{i}              { return new Symbol(TokenConstants.FI); }
<YYINITIAL>{i}{f}              { return new Symbol(TokenConstants.IF); }
<YYINITIAL>{i}{n}              { return new Symbol(TokenConstants.IN); }
<YYINITIAL>{i}{n}{h}{e}{r}{i}{t}{s}    { return new Symbol(TokenConstants.INHERITS); }
<YYINITIAL>{l}{e}{t}           { return new Symbol(TokenConstants.LET); }
<YYINITIAL>{l}{o}{o}{p}        { return new Symbol(TokenConstants.LOOP); }
<YYINITIAL>{p}{o}{o}{l}        { return new Symbol(TokenConstants.POOL); }
<YYINITIAL>{t}{h}{e}{n}        { return new Symbol(TokenConstants.THEN); }
<YYINITIAL>{w}{h}{i}{l}{e}     { return new Symbol(TokenConstants.WHILE); }
<YYINITIAL>{c}{a}{s}{e}        { return new Symbol(TokenConstants.CASE); }
<YYINITIAL>{e}{s}{a}{c}        { return new Symbol(TokenConstants.ESAC); }
<YYINITIAL>{o}{f}              { return new Symbol(TokenConstants.OF); }
<YYINITIAL>{n}{e}{w}           { return new Symbol(TokenConstants.NEW); }
<YYINITIAL>{i}{s}{v}{o}{i}{d}  { return new Symbol(TokenConstants.ISVOID); }
<YYINITIAL>{n}{o}{t}           { return new Symbol(TokenConstants.NOT); }
<YYINITIAL>t{r}{u}{e}          { return new Symbol(TokenConstants.BOOL_CONST, true); }
<YYINITIAL>f{a}{l}{s}{e}       { return new Symbol(TokenConstants.BOOL_CONST, false); } 


<YYINITIAL>{QUOTE}      { 
                        /* Start of a string */
                        yybegin(STRING);
                        coolStr = new CoolStringBuilder();
                        }
<STRING>[^{QUOTE}{NEWLINE}{SLASH}]*|{ESC_SEQ} {
                        /* This strategy adopted in matching strings constants
                         * is to match single-line substrings seperately and 
                         * then to piece them together
                         * The SLASH is excluded in the match on single-line
                         * strings as SLASH is indicative of a escape sequence
                         * represented literally by two characters but in
                         * essence representing just one. We would want to
                         * recognize them as one using ESC_SEQ.
                         * Multi-line string constants are broken up by escaped
                         * newlines which is caught ESC_SEQ.
                         * The NEWLINE in the earlier part of the regular
                         * expression indicates an unterminated string which
                         * is handled below.
                         */
                        if (yytext().charAt(yytext().length() - 1) == '\n')
                           curr_lineno++;
						try { coolStr.append(yytext()); }
						catch(NullInCoolStringException e)  { 
						    return new Symbol(TokenConstants.ERROR,
							    "String contains null character");
						}
						catch(EscapedNullInCoolStringException e) {
						    return new Symbol(TokenConstants.ERROR,
							    "String contains an escaped null character");
						}
                        }
<STRING>{NEWLINE}       {
                            /* It is an error to break a string using an
                             * unescaped newline. However, an error is flagged
                             * only if no other previous error in the string
                             * constant has been found.
                             */ 
                            ++curr_lineno;
                            yybegin(YYINITIAL);
                            if (!coolStr.inError())
                                return new Symbol(TokenConstants.ERROR, 
                                    "Unterminated string constant");
                        }
<STRING>{QUOTE}         {
                        /* The end of a string constant*/
	                    if (coolStr.length() > MAX_STR_CONST)
                        {
                            coolStr.setError();
                            yybegin(YYINITIAL);
                            return new Symbol(TokenConstants.ERROR,
                                "String constant too long");
                         }
                         yybegin(YYINITIAL);
                         if (!coolStr.inError())
                            return new Symbol(TokenConstants.STR_CONST, 
                                        AbstractTable.stringtable.addString(coolStr.toString()));
                         }


<YYINITIAL>[0-9]+   { return new Symbol(TokenConstants.INT_CONST,
                                        AbstractTable.inttable.addString(yytext()));}


<YYINITIAL>[A-Z][a-zA-Z_0-9]*   { return new Symbol(TokenConstants.TYPEID,
                                        AbstractTable.idtable.addString(yytext()));}
                                                    
<YYINITIAL>[a-z][a-zA-Z_0-9]*   { return new Symbol(TokenConstants.OBJECTID,
                                        AbstractTable.idtable.addString(yytext()));}

<YYINITIAL>\n   {++curr_lineno;}

<YYINITIAL>[ \t\f\r\013]+ {;}


<YYINITIAL>.    { return new Symbol(TokenConstants.ERROR, yytext().charAt(0)); }
